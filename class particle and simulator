# numpy as np 
import numpy as np
import math

## Author Adam Rustom 

## Class Particle

#Part 1:
class particle:
    def __init__(self, x, y, charge):
        self.posx: float = x 
        self.posy: float = y
        self.posv = np.array([self.posx, self.posy])
        self.charge = charge  # positive | - negative
    
    def get_pos(self):
        return self.posv
    def get_charge(self):
        return self.charge

## Class simulator 
#Part 2
class simulator:
    def __init__(self, list_particle):
        self.particles = list_particle  # List of all the particles
    
    ## Part Three
    def add(self, particle):  # 1
        self.particles = np.append(self.particles, particle)
    
    def remove(self, p1):  # 2
        index = np.where(self.particles == p1)[0][0]
        self.particles = np.delete(self.particles, index, axis=0)
    
    def get_pos(self):  # 3
        pos_list = np.array([p.get_pos() for p in self.particles]).T
        return pos_list
    
    def total_charge(self):  # 4
        total_charge = 0
        for i in range(len(self.particles)):
            total_charge += self.particles[i].charge
        return total_charge
    
    def set_charge(self, p: particle, new_charge): #5
        index = np.where(self.particles == p)[0][0]
        self.particles[index].charge = new_charge

    def set_pos(self,p,x,y): #6
        index = np.where(self.particles == p)[0] #Finds an index for which p is in self.particles
        if len(index)>0:
            self.particles[index[0]].posv = np.array([x,y])

    def get_distance(self, p1: particle, p2: particle):  # 7: Use pythagoras theorem, we could also subtract the vectors, and compute the norm.
        return math.sqrt((p1.posv[1] - p2.posv[1])**2 + (p1.posv[0] - p2.posv[0])**2)
    
    def remove_all(self): #8 
        self.particles = np.array([])
    
    #Part four: computation
    def get_electric_field_pos(self,position):
        k = 8.9875e9 #Columbs force
        total_force = np.array([0.0,0.0])
        for particle in self.particles: # Runs a forloop, that add all the the forces and their impact at that position.
            r = position-particle.get_pos()
            r_mag = np.linalg.norm(r)
            if r_mag>0:
                total_force +=k*particle.get_charge()/(r_mag**2)*(r/r_mag)
        return total_force
    def get_colomb_force_particle(self,target_particle):
        k = 8.9875e9 #Colombss force
        total_force = np.array([0.0,0.0]) #Intializing a vector 'total_force'
        for particle in self.particles:   #Runs a for loop, that adds all the forces acting on particle using colombs law
            if particle!=target_particle:
                r = target_particle.get_pos() - particle.get_pos()
                r_mag = self.get_distance(target_particle,particle)
                if r_mag>0:
                    total_force += (k * particle.get_charge())/(r_mag **2)*(r/r_mag)
        return total_force



#Test cases
particle1 = particle(1, 1, 1)
particle2 = particle(2, 2, -1)
particle3 = particle(3, 3, 2)

# An isntance 'sim' is created
sim = simulator(np.array([particle1, particle2]))

# Test changing charge and position
sim.set_charge(particle1, 2)
sim.set_pos(particle2, 4, 4)

print("New Charge of Particle 1:", particle1.get_charge())
print("New Position of Particle 2:", particle2.get_pos())

# Test electric field and Coulomb force
electric_field_pos = sim.get_electric_field_pos(np.array([0, 0]))
coulomb_force_particle3 = sim.get_colomb_force_particle(particle3)

print("Electric Field at Position (0, 0):", electric_field_pos)
print("Coulomb Force on Particle 3:", coulomb_force_particle3)







